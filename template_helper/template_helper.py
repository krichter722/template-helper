#!/usr/bin/python
# -*- coding: utf-8 -*-

#    This program is free software: you can redistribute it and/or modify
#    it under the terms of the GNU General Public License as published by
#    the Free Software Foundation, either version 3 of the License, or
#    (at your option) any later version.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU General Public License for more details.
#
#    You should have received a copy of the GNU General Public License
#    along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
#    Dieses Programm ist Freie Software: Sie können es unter den Bedingungen
#    der GNU General Public License, wie von der Free Software Foundation,
#    Version 3 der Lizenz oder (nach Ihrer Wahl) jeder neueren
#    veröffentlichten Version, weiterverbreiten und/oder modifizieren.
#
#    Dieses Programm wird in der Hoffnung, dass es nützlich sein wird, aber
#    OHNE JEDE GEWÄHRLEISTUNG, bereitgestellt; sogar ohne die implizite
#    Gewährleistung der MARKTFÄHIGKEIT oder EIGNUNG FÜR EINEN BESTIMMTEN ZWECK.
#    Siehe die GNU General Public License für weitere Details.
#
#    Sie sollten eine Kopie der GNU General Public License zusammen mit diesem
#    Programm erhalten haben. Wenn nicht, siehe <http://www.gnu.org/licenses/>.

import os
import logging
import tempfile
import subprocess as sp
import python_essentials
import python_essentials.lib
import python_essentials.lib.os_utils as os_utils
import re

logger = logging.getLogger(__name__)
logger.setLevel(logging.INFO)
ch = logging.StreamHandler()
ch.setLevel(logging.INFO)
logger.addHandler(ch)

difftool_default = "meld"
comment_symbol_default = "#"
pathes_re = "/?(.+/)+.+"

def template_header(tmpl_file_path, symbol=comment_symbol_default):
    """
    Generates line breaks for a one or multiline path statement in the "Don't
    modify statement" in a template output file. Rather than dealing with an
    offset at the beginning the file path can always start in a new line and
    contain a newline character at the end. Usage could be the following

    ################################################################################
    # DO NOT MODIFY THIS FILE.                                                     #
    # It is generated by the                                                       #
    $template_helper($tmpl_file_path)
    # template. Make modifications there and regenerate this file.                 #
    ################################################################################

    """
    ret_value = ""
    remaining = tmpl_file_path
    while len(remaining) > 0:
        ret_value += "%s " % (symbol,)
        if len(remaining) < 80-2-2:
            ret_value += remaining
            ret_value += " "*(80-2-2-len(remaining))
            remaining = ""
            ret_value += " %s" % (symbol,)
        else:
            ret_value += remaining[:80-2-2]
            remaining = remaining[80-2-2:]
            ret_value += " %s\n" % (symbol,)
    return ret_value

def template_header_xml(tmpl_file_path):
    ret_value = ""
    remaining = tmpl_file_path
    while len(remaining) > 0:
        if len(remaining) < 80:
            ret_value += remaining
            remaining = ""
        else:
            ret_value += remaining[:80]
            remaining = remaining[80:]
            ret_value += "\n"
    return ret_value

def write_template_file(tmpl_str, target, check_output=True, difftool=difftool_default, ignore_pathes=True, comment_symbol=comment_symbol_default):
    """writes `tmpl_str` into the path pointed to by
    `target`. If `check_output` is `True` and the file pointed to by
    `target` exists its content is compared to the generated `str` and the
    `difftool` command is invoked with the file pointed to by `target` and the
    generated `str` written into a temporary file (because `melt` only
    accepts file paths as argument) if the two don't match.

    The `ignore_pathes` flag allows to skip all pathes matching %(pathes_re)s.
    It requires knowledge about the comment symbol being used in the template
    helper.
    """ % {"pathes_re": pathes_re}
    if comment_symbol is None:
        raise ValueError("comment_symbol mustn't be None")
    # check existence and executability of difftool only if needed
    if os.path.exists(target) and os.path.isdir(target):
        raise ValueError("target '%s' exists and is a directory" % (target,))
    if check_output and os.path.exists(target):
        target_file = open(target, "r")
        target_file_content = target_file.read()
        def __handle_diff__(file0, file1):
            # check whether difftool exists and is executable
            if os_utils.which(difftool) is None:
                raise ValueError("specified difftool '%s' isn't available or not executable" % (difftool,))
            logger.warn("template result doesn't match with content of existing target file '%s', opening difftool '%s' in order to investigate" % (target, difftool))
            difftool_cmds = [difftool, file0, file1]
            logger.info("invoking difftool command '%s' in order to visualize changes" % (str.join(" ", difftool_cmds),))
            sp.check_call(difftool_cmds)
            answer = None
            while answer != "y" and answer != "n" and answer != "s":
                answer = raw_input("Proceed with script yes/no (aborts the script)/skip (the generation of file '%s') (y/n/s)? " % (target,))
            if answer == "s":
                logger.info("skipping generation of file '%s' as requested by input" % (target,))
                return
            if answer == "n":
                raise RuntimeError("Aborted by user")
        if not ignore_pathes:
            if tmpl_str != target_file_content:
                tmpl_str_temp_file, tmpl_str_temp_file_path = tempfile.mkstemp(text=True)
                logger.info("writing template result for target '%s' into temporary file '%s' in order to be able to pass it to difftool" % (target, tmpl_str_temp_file_path,))
                os.write(tmpl_str_temp_file, tmpl_str)
                os.close(tmpl_str_temp_file)
                __handle_diff__(target, tmpl_str_temp_file_path)
        else:
            # search for one or more (sequential) lines which match pathes_re and the surrounding comment symbols; fail if another line matching the pattern is found
            target_file_lines = target_file_content.split("\n")
            tmpl_str_lines = tmpl_str.split("\n")
            if comment_symbol != "":
                pathes_re_complete = "%s %s/?[\\s]+%s" % (comment_symbol, pathes_re, comment_symbol)
            else:
                pathes_re_complete = "%s/?" % (pathes_re,)
            target_match_found = False
            tmpl_match_found = False
            target_preceeding_match = False # whether the preceeding line has been a match (necessary to solve context sensitive problem based on lines)
            tmpl_preceeding_match = False
            target_file_lines0 = []
            tmpl_str_lines0 = []
            for target_file_line in target_file_lines:
                if re.match(pathes_re_complete, target_file_line) is None:
                    target_file_lines0.append(target_file_line)
                    target_preceeding_match = False
                else:
                    target_preceeding_match = True
                    if target_match_found and not target_preceeding_match:
                        raise RuntimeError("more than one line in target file '%s' matches regular expression '%s'" % (target, pathes_re_complete))
                    target_match_found = True
            for tmpl_str_line in tmpl_str_lines:
                if re.match(pathes_re_complete, tmpl_str_line) is None:
                    tmpl_str_lines0.append(tmpl_str_line)
                    tmpl_preceeding_match = False
                else:
                    tmpl_preceeding_match = True
                    if tmpl_match_found and not tmpl_preceeding_match:
                        raise RuntimeError("more than one line in target file '%s' matches regular expression '%s'" % (target, pathes_re_complete))
                    tmpl_match_found = True
            if target_file_lines0 != tmpl_str_lines0:
                target_lines_tmp_file_path = tempfile.mkstemp()[1]
                tmpl_lines_tmp_file_path = tempfile.mkstemp()[1]
                target_lines_tmp_file = open(target_lines_tmp_file_path, "w")
                tmpl_lines_tmp_file = open(tmpl_lines_tmp_file_path, "w")
                target_lines_tmp_file.writelines([i+"\n" for i in target_file_lines0])
                tmpl_lines_tmp_file.writelines([i+"\n" for i in tmpl_str_lines0])
                target_lines_tmp_file.close()
                tmpl_lines_tmp_file.close()
                __handle_diff__(target_lines_tmp_file_path, tmpl_lines_tmp_file_path)
        target_file.close()
    target_parent = os.path.dirname(target)
    if not os.path.exists(target_parent):
        os.makedirs(target_parent)
    t_file = open(target, "w+") # open target for writing after opening and
        # closing it for reading
    t_file.write(tmpl_str)
    t_file.flush()
    t_file.close()
    logger.info("created %s" % (target,))
